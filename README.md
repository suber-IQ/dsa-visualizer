# ğŸŒŸ DSA-Visualizer ğŸŒŸ
![dsa-visualizer](https://res.cloudinary.com/suberiq/image/upload/v1741385735/wtifabpps99ynqyghhb5.jpg)
## ğŸš€ Introduction
DSA-Visualizer is an interactive and educational tool designed to help users **understand and visualize** fundamental **Data Structures and Algorithms (DSA)**. This project provides an engaging way to explore sorting, searching, graph algorithms, dynamic programming, greedy techniques, backtracking, tree algorithms, and mathematical computations.

## ğŸ¯ Features
âœ… **Interactive Visualizations** â€“ See step-by-step execution of algorithms.  
âœ… **User-Friendly Interface** â€“ Easy-to-navigate UI with real-time animations.  
âœ… **Performance Metrics** â€“ Analyze time complexity and execution speed.  
âœ… **Code Snippets** â€“ Each algorithm includes well-documented code.  
âœ… **Custom Inputs** â€“ Users can enter their own test cases.  
âœ… **Educational Purpose** â€“ Designed for students, educators, and DSA enthusiasts.  

---

## ğŸ“Œ Algorithms Implemented

### ğŸ”· 1. Sorting Algorithms
Sorting algorithms arrange elements in a particular order.
- ğŸŸ¢ **Bubble Sort** â€“ A simple comparison-based algorithm.
- ğŸŸ¢ **Selection Sort** â€“ Repeatedly selects the smallest element.
- ğŸŸ¢ **Insertion Sort** â€“ Efficient for small datasets.
- ğŸ”µ **Merge Sort** â€“ A divide-and-conquer approach.
- ğŸ”µ **Quick Sort** â€“ Uses partitioning to sort efficiently.

### ğŸ”¶ 2. Searching Algorithms
Searching algorithms help in finding an element in a dataset.
- ğŸ” **Linear Search** â€“ Iterates through the list sequentially.
- ğŸ” **Binary Search** â€“ Uses a divide-and-conquer strategy (requires sorted input).

### ğŸ”· 3. Graph Algorithms
Graph-based techniques are widely used in networking, maps, and AI.
- ğŸŸ£ **BFS (Breadth-First Search)** â€“ Explores neighbors before deeper nodes.
- ğŸŸ£ **DFS (Depth-First Search)** â€“ Explores as far as possible before backtracking.
- ğŸŸ£ **Dijkstraâ€™s Algorithm** â€“ Finds the shortest path in weighted graphs.
- ğŸŸ¡ **Primâ€™s Algorithm** â€“ Constructs a minimum spanning tree.
- ğŸŸ¡ **Kruskalâ€™s Algorithm** â€“ Another method for minimum spanning tree construction.

### ğŸ”¶ 4. Dynamic Programming
Optimized solutions by breaking problems into subproblems.
- ğŸ”¢ **Fibonacci Sequence** â€“ Uses memoization for efficiency.
- ğŸ’ **Knapsack Problem** â€“ Optimizes item selection for maximum value.
- ğŸ“– **Longest Common Subsequence (LCS)** â€“ Finds the longest matching sequence.
- ğŸ“ˆ **Longest Increasing Subsequence (LIS)** â€“ Determines the longest ascending subsequence.

### ğŸ”· 5. Greedy Algorithms
Algorithms that make the best local choice at each step.
- â³ **Activity Selection Problem** â€“ Selects maximum non-overlapping activities.
- ğŸ—œ **Huffman Coding** â€“ Used in data compression for optimal encoding.

### ğŸ”¶ 6. Backtracking
A trial-and-error approach to explore all possible solutions.
- â™Ÿ **N-Queens Problem** â€“ Places N queens on an NxN chessboard.
- ğŸ§© **Sudoku Solver** â€“ Solves Sudoku puzzles using constraint satisfaction.

### ğŸŒ³ 7. Tree Algorithms
Tree structures are fundamental to hierarchical data representation.
- ğŸŒ¿ **Tree Traversals** â€“ Preorder, Inorder, Postorder traversals.
- ğŸŒ³ **Binary Search Tree (BST) Operations** â€“ Insert, delete, search.
- ğŸ”„ **AVL Tree Rotations** â€“ Self-balancing BST with rotation operations.
- ğŸ” **Lowest Common Ancestor (LCA)** â€“ Finds the closest common ancestor of two nodes.

### ğŸ”¢ 8. Mathematical Algorithms
Mathematical computations and number theory algorithms.
- ğŸ”¢ **GCD (Greatest Common Divisor) - Euclidean Algorithm** â€“ Efficient GCD computation.
- ğŸ§® **Sieve of Eratosthenes** â€“ Finds all prime numbers up to a given limit.
- ğŸ§© **Prime Factorization** â€“ Determines prime factors of a number.

---

## ğŸ›  Installation
To run **DSA-Visualizer** locally:
```sh
# Clone the repository
git clone https://github.com/suber-IQ/dsa-visualizer.git

# Navigate to the project directory
cd DSA-Visualizer

# Install dependencies (if applicable)
pnpm install  # For JavaScript-based projects
```

## ğŸ® Usage
1. **Launch the application**:
   ```sh
   pnpm start   # For JavaScript-based projects
   ```
2. **Select an algorithm** from the UI.
3. **Input custom data** or use predefined examples.
4. **Observe step-by-step visualizations**.

## ğŸ”§ Technologies Used
- **Programming Languages**: JavaScript
- **Frontend**: React.js, Typescript, Tailwind Css
- **Data Structures**: Sorting,Searching,Graph,Dp,Tree etc..

---

## ğŸ¤ Contributing
ğŸ‰ Contributions are welcome! To contribute:
1. **Fork the repository**.
2. **Create a new branch**: `git checkout -b feature-branch`.
3. **Commit your changes**: `git commit -m 'Added new feature'`.
4. **Push to the branch**: `git push origin feature-branch`.
5. **Submit a pull request**.

---



## ğŸ“¬ Contact
For queries or suggestions:
ğŸ“§ Email: suberquercusumit@gmail.com  
ğŸ”— GitHub: [suberiq](https://github.com/yourusername)  

---



